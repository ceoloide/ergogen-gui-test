{"version":3,"file":"static/js/787.2a7408b0.chunk.js","mappings":"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","sources":["workers/jscad.worker.ts"],"sourcesContent":["/* eslint-env worker */\n/* global self */\n\nimport { JscadWorkerRequest, JscadWorkerResponse } from './jscad.worker.types';\n\nconsole.log('<-> JSCAD worker module starting...');\n\n/**\n * Error handler for uncaught errors in the worker.\n */\nself.onerror = (error) => {\n  console.error('>>> Uncaught error in JSCAD worker:', error);\n  const errorMessage =\n    error instanceof ErrorEvent ? error.message : String(error);\n  self.postMessage({\n    type: 'error',\n    error: `JSCAD worker error: ${errorMessage}`,\n  });\n  return true; // Prevent default error handling\n};\n\n// Create minimal mock of document object for openjscad.js\n// The library expects DOM APIs; we provide minimal shims and a simple event system\nconst docListeners: Record<string, Array<(ev?: any) => void>> = {};\nconst makeStubElement = () => {\n  const options: any = {\n    length: 0,\n    remove: () => {},\n    add: () => {},\n  };\n  return {\n    style: {},\n    firstChild: { textContent: '' },\n    className: '',\n    text: '',\n    value: 0,\n    min: 0,\n    max: 0,\n    options,\n    appendChild: () => {},\n    setAttribute: () => {},\n  } as any;\n};\n(self as any).document = {\n  getElementById: (_id?: string) => makeStubElement(),\n  createElement: (_tag?: string) => makeStubElement(),\n  implementation: {},\n  location: { href: '' },\n  addEventListener: (type: string, listener: (ev?: any) => void) => {\n    (docListeners[type] ||= []).push(listener);\n  },\n  dispatchEvent: (evt: any) => {\n    const type = typeof evt === 'string' ? evt : evt?.type;\n    (docListeners[type] || []).forEach((fn) => {\n      try {\n        fn(evt);\n      } catch (_e) {\n        /* noop */\n      }\n    });\n  },\n};\n\n// Global interface for the myjscad library loaded from openjscad.js\ninterface MyJscad {\n  setup: () => void;\n  compile: (code: string) => Promise<string>;\n  generateOutput: (\n    format: string,\n    geometry: unknown\n  ) => {\n    asBuffer: () => {\n      toString: () => string;\n    };\n  };\n}\n\ndeclare global {\n  interface Window {\n    myjscad: ((opts: unknown) => MyJscad) | MyJscad;\n  }\n}\n\n// Create window alias for self since openjscad.js expects window.myjscad\n// In a web worker, window doesn't exist, so we alias it to self\n(self as any).window = self;\n\nlet jscadInstance: MyJscad | null = null;\nlet initializationError: Error | null = null;\n\n// Wrap initialization in a self-invoking async function to handle promises\nconst initializationPromise = (async () => {\n  try {\n    // @ts-expect-error - importScripts is available in web workers\n    importScripts('/dependencies/openjscad.js');\n\n    // The vendor bundle registers an init() on DOMContentLoaded which defines\n    // window.myjscad.setup/compile/generateOutput. In a worker there's no DOMContentLoaded,\n    // so we manually dispatch it now that the script is loaded.\n    // Give the bundle a tick to finish registering listeners, then dispatch.\n    await new Promise((r) => setTimeout(r, 0));\n    (self as any).document.dispatchEvent?.('DOMContentLoaded');\n\n    // Retry a few times in case the init runs asynchronously.\n    const maxAttempts = 5;\n    let attempt = 0;\n    while (attempt < maxAttempts) {\n      const candidate = (window as any).myjscad as Partial<MyJscad> | undefined;\n      const hasApi =\n        !!candidate &&\n        typeof candidate.setup === 'function' &&\n        typeof candidate.compile === 'function' &&\n        typeof candidate.generateOutput === 'function';\n      if (hasApi) {\n        jscadInstance = candidate as MyJscad;\n        break;\n      }\n      attempt += 1;\n      // small delay between attempts\n      await new Promise((r) => setTimeout(r, 10));\n    }\n\n    if (!jscadInstance) {\n      const currentKeys = Object.keys((window as any).myjscad || {});\n      console.error(\n        'JSCAD init: myjscad not ready after attempts; keys =',\n        currentKeys\n      );\n      throw new Error(\n        'window.myjscad was not correctly populated by openjscad.js script.'\n      );\n    }\n    console.log('<-> OpenJSCAD library loaded and initialized in worker');\n  } catch (error) {\n    // Capture initialization error and log it; onmessage will report back to caller\n    initializationError =\n      error instanceof Error ? error : new Error(String(error));\n    console.error(\n      '>>> Failed to load or initialize OpenJSCAD library:',\n      initializationError\n    );\n  }\n})();\n\n/**\n * Main worker message handler.\n */\nself.onmessage = async (event: MessageEvent<JscadWorkerRequest>) => {\n  // Wait for the initialization to complete before processing any message\n  await initializationPromise;\n\n  const { type, jscad, requestId } = event.data || {};\n\n  if (initializationError) {\n    const response: JscadWorkerResponse = {\n      type: 'error',\n      error: `JSCAD library initialization failed: ${initializationError}`,\n      requestId,\n    };\n    self.postMessage(response);\n    return;\n  }\n\n  if (!jscadInstance) {\n    throw new Error('JSCAD library is not loaded or initialized correctly.');\n  }\n\n  if (type !== 'jscad_to_stl') {\n    const response: JscadWorkerResponse = {\n      type: 'error',\n      error: `Unknown message type: ${type}`,\n      requestId,\n    };\n    self.postMessage(response);\n    return;\n  }\n  try {\n    if (!jscad || jscad.trim() === '') {\n      throw new Error('JSCAD script is empty.');\n    }\n\n    // This logic is adapted from the original convertJscadToStl utility function.\n    jscadInstance.setup();\n    await jscadInstance.compile(jscad);\n    const output = jscadInstance.generateOutput('stla', null); // 'stla' for ASCII STL\n    const stlContent = output.asBuffer().toString();\n\n    if (!stlContent || stlContent.trim() === '') {\n      throw new Error('Generated STL content is empty.');\n    }\n\n    const response: JscadWorkerResponse = {\n      type: 'success',\n      stl: stlContent,\n      requestId,\n    };\n    self.postMessage(response);\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const response: JscadWorkerResponse = {\n      type: 'error',\n      error: `JSCAD to STL conversion failed: ${errorMessage}`,\n      requestId,\n    };\n    self.postMessage(response);\n  }\n};\n\n// Export empty object to satisfy TypeScript's module requirement\nexport {};\n"],"names":["console","log","self","onerror","error","errorMessage","ErrorEvent","message","String","postMessage","type","concat","docListeners","document","getElementById","_id","style","firstChild","textContent","className","text","value","min","max","options","length","remove","add","appendChild","setAttribute","createElement","_tag","implementation","location","href","addEventListener","listener","push","dispatchEvent","evt","forEach","fn","_e","window","jscadInstance","initializationError","initializationPromise","_document$dispatchEve","_document","importScripts","Promise","r","setTimeout","call","maxAttempts","attempt","candidate","myjscad","setup","compile","generateOutput","currentKeys","Object","keys","Error","onmessage","async","jscad","requestId","event","data","response","trim","stlContent","asBuffer","toString","stl"],"sourceRoot":""}